<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>ANTLR 2.00 Tree Construction</title>
</head>

<body bgcolor="#FFFFFF" text="#000000">

<table border="0">
  <tr>
    <td align="center" valign="top" width="120" bgcolor="#FBFCDC"><font color="#FFFFFF"
    size="4"><img src="logo.gif" width="111" height="144"><br>
    </font><strong><a href="http://www.magelang.com"><font size="3">M</font><font size="2">AGELANG</font></a><font
    size="3">!</font></strong><p><a href="http://www.ANTLR.org"><font size="4">Home</font></a></td>
    <td></td>
    <td valign="top" width="520"><h1><a name="_bb1">ANTLR Tree Construction</a></h1>
    <p>ANTLR helps you build intermediate form trees, or abstract syntax trees (ASTs), by
    providing grammar annotations that indicate what tokens are to be treated at subtree
    roots, which are to be leaves, and which are to be ignored with respect to tree
    construction. In a future version, you will also be able to specify tree rewrite rules. As
    with 1.33, you may manipulate trees using grammar actions. </p>
    <p>It is often the case that programmers either have existing tree definitions or need a
    special physical structure, thus, preventing ANTLR from specifically defining the
    implementation of AST nodes. ANTLR specifies only an interface describing minimum
    behavior. Your tree implementation must implement this interface so ANTLR knows how to
    work with your trees. Further, you must tell the parser the name of your tree nodes or
    provide a tree &quot;factory&quot; so that ANTLR knows how to create nodes with the
    correct type (rather than hardcoding in a <tt>new AST()</tt> expression everywhere). </p>
    <h2><a name="_bb2"></a><a name="Notation">Notation</a></h2>
    <p>In this and other documents, tree structures are represented by a LISP-like notation,
    for example: </p>
    <pre><tt>#(A B C)</tt></pre>
    <p>is a tree with A at the root, and children B and C. This notation can be nested to
    describe trees of arbitrary structure, for example: </p>
    <pre><tt>#(A B #(C D E))</tt></pre>
    <p>is a tree with A at the root, B as a first child, and an entire subtree as the second
    child. The subtree, in turn, has C at the root and D,E as children. </p>
    <h2><a name="_bb3"></a><a name="Controlling AST construction">Controlling AST construction</a></h2>
    <p>AST construction in an ANTLR Parser, or AST transformation in a Tree-Parser, is turned
    on and off by the <a href="options.html#buildAST"><tt>buildAST</tt> option</a>. </p>
    <h2><a name="_bb4"></a><a name="Grammar annotations for building ASTs">Grammar annotations
    for building ASTs</a></h2>
    <h3><a name="_bb5"></a><a name="Leaf nodes">Leaf nodes</a></h3>
    <p>ANTLR assumes that any nonsuffixed token reference or token-range is a leaf node in the
    resulting tree for the enclosing rule. If no suffixes at all are specified in a grammar,
    then a Parser will construct a linked-list of the tokens (a degenerate AST), and a
    Tree-Parser will copy the input AST. </p>
    <h3><a name="_bb6"></a><a name="Root nodes">Root nodes</a></h3>
    <p>Any token suffixed with the &quot;<tt>^</tt>&quot; operator is considered a root token.
    A tree node is constructed for that token and is made the root of whatever portion of the
    tree has been built </p>
    <pre><tt>a : A B^ C^ ;</tt></pre>
    <p>results in tree <tt>#(C #(B A))</tt>.</p>
    <p>First A is matched and made a lonely child, followed by B which is made the parent of
    the current tree, A. Finally, C is matched and made the parent of the current tree, making
    it the parent of the B node. Note that the same rule without any operators results in the
    flat tree <tt>A B C</tt>. </p>
    <h3><a name="_bb7"></a><a name="Turning off standard tree construction">Turning off
    standard tree construction</a></h3>
    <p>Suffix a token reference with &quot;<tt>!</tt>&quot; to prevent incorporation of the
    node for that token into the resulting tree (the AST node for the token is still
    constructed and may be referenced in actions, it is just not added to the result tree
    automatically). Suffix a rule reference &quot;<tt>!</tt>&quot; to indicate that the tree
    constructed by the invoked rule should not be linked into the tree constructed for the
    current rule. </p>
    <p>Suffix a rule definition with &quot;<tt>!</tt>&quot; to indicate that tree construction
    for the rule is to be turned off. Rules and tokens referenced within that rule still
    create ASTs, but they are not linked into a result tree. The following rule does no
    automatic tree construction. Actions must be used to set the return AST value, for
    example: </p>
    <pre><tt>begin!
    :   INT PLUS i:INT
        { #begin = #(PLUS INT i); }
    ;</tt></pre>
    <p>For finer granularity, prefix alternatives with &quot;<tt>!</tt>&quot; to shut off tree
    construction for that alternative only. This granularity is useful, for example, if you
    have a large number of alternatives and you only want one to have manual tree
    construction: </p>
    <pre><tt>stat:   
        ID EQUALS^ expr   // automatic construction
    ... some alternatives ...
    |!  RETURN expr
        { #stat = #([IMAGINARY_TOKEN_TYPE] expr); }
    ... more alternatives ...
    ;</tt> </pre>
    <h3><a name="_bb8"></a><a name="Tree and tree node construction">Tree node construction</a></h3>
    <p>With automatic tree construction off (but with <code>buildAST</code> on), you must
    construct your own tree nodes and combine them into tree structures within embedded
    actions. There are several ways to create a tree node in an action: <ol>
      <li>use <tt>new <i>T</i>(<i>arg</i>)</tt> where <i>T</i> is your tree node type and <i>arg</i>
        is either a single token type, a token type and token text, or a <tt>Token</tt>. </li>
      <li>use <tt>ASTFactory.create(<i>arg</i>)</tt> where <i>T</i> is your tree node type and <i>arg</i>
        is either a single token type, a token type and token text, or a <tt>Token</tt>. Using the
        factory is more general than creating a new node directly, as it defers the node-type
        decision to the factory, and can be easily changed for the entire grammar. </li>
      <li>use the shorthand notation #[TYPE] or #[TYPE,&quot;text&quot;]. The shorthand notation
        results in a call to ASTFactory.create(). </li>
      <li>use the shorthand notation #<i>id</i>, where <i>id</i> is either a token matched in the
        rule, a label, or a rule-reference.</li>
    </ol>
    <p>To construct a tree structure from a set of nodes, you can set the first-child and
    next-sibling references yourself or call the factory <tt>make</tt> method or use <tt>#(...)</tt>
    notation described below. </p>
    <h3><a name="_bb9"></a><a name="Action Translation">AST Action Translation</a></h3>
    <p>In parsers and tree parsers with <tt>buildAST</tt> set to true, ANTLR will translate
    portions of user actions in order to make it easier to build ASTs within actions. In
    particular, the following constructs starting with '#' will be translated: <dl>
      <dt><tt>#<i>label</i></tt> </dt>
      <dd>The AST associated with a labeled token-reference or rule-reference may be accessed as <tt>#<i>label</i></tt>.
        The translation is to a variable containing the AST node built from that token, or the AST
        returned from the rule. </dd>
      <dt><tt>#<i>rule</i></tt> </dt>
      <dd>When <i>rule</i> is the name of the enclosing rule, ANTLR will translate this into the
        variable containing the result AST for the rule. This allows you to set the return AST for
        a rule or examine it from within an action. This can be used when AST generation is on or
        suppressed for the rule or alternate. For example: <pre><tt>r! : a:A { #r = #a; }</tt></pre>
      </dd>
      <dd><font face="Times New Roman">Setting the return tree is very useful in combination with
        normal tree construction because you can have ANTLR do all the work of building a tree and
        then add an imaginary root node such as:</font></dd>
      <dd>&nbsp;</dd>
      <dd><pre><tt>decl : ( TYPE ID )+
       { #decl = #([DECL,&quot;decl&quot;], #decl); }
     ;</tt></pre>
      </dd>
      <dd>ANTLR allows you to assign to <font size="2" face="Courier New">#rule</font> anywhere
        within an alternative of the rule. ANTLR ensures that references of and assignments to <font
        size="2" face="Courier New">#rule</font> within an action force the parser's internal AST
        construction variables into a stable state. After you assign to <font size="2"
        face="Courier New">#rule</font>, the state of the parser's automatic AST construction
        variables will be set as if ANTLR had generated the tree rooted at <font size="2"
        face="Courier New">#rule</font>. For example, any children nodes added after the action
        will be added to the children of <font size="2" face="Courier New">#rule</font>.</dd>
      <dt><tt>#<i>label</i>_in</tt> </dt>
      <dd>In a tree parser, the <b>input</b> AST associated with a labeled token reference or rule
        reference may be accessed as <tt>#<i>label</i>_in</tt>. The translation is to a variable
        containing the input-tree AST node from which the rule or token was extracted. Input
        variables are seldom used. You almost always want to use <tt>#<i>label</i></tt> instead of
        <tt>#<i>label</i>_in</tt>.</dd>
      <dt>&nbsp;</dt>
      <dt><tt>#<i>id</i></tt> </dt>
      <dd>ANTLR supports the translation of unlabeled token references and rule references as a
        shorthand notation, as long as the token or rule name is unique within the scope of a
        single alternative. In these cases, the use of an unlabeled token reference or rule
        reference is identical to using a label. For example, this: <pre><tt>
r! : A { #r = #A; }
</tt>  </pre>
        <p>is equivalent to: </p>
        <pre><tt>
r! : a:A { #r = #a; }</tt></pre>
      </dd>
      <dd><tt>#<i>id</i>_in</tt> is given similar treatment to <tt>#<i>label</i>_in.</tt></dd>
      <dt>&nbsp;</dt>
      <dt><tt>#[<i>TOKEN_TYPE</i>]</tt> or <tt>#[<i>TOKEN_TYPE</i>,&quot;text&quot;]</tt> </dt>
      <dd>AST node constructor shorthand. The translation is a call to the <tt>ASTFactory.create()</tt>
        method.&nbsp; For example, <tt>#[T]</tt> is translated to: <pre><tt>ASFFactory.create(T)</tt></pre>
      </dd>
      <dt><tt>#(<i>root</i>, <i>c1</i>, ..., <i>cn</i>)</tt> </dt>
      <dd>AST tree construction shorthand. ANTLR looks for the comma character to separate the
        tree arguments. Commas within method call tree elements are handled properly; i.e., an
        element of &quot;<tt>foo(#a,34)</tt>&quot; is ok and will not conflict with the comma
        separator between the other tree elements in the tree. This tree construct is translated
        to a &quot;make tree&quot; call. The &quot;make-tree&quot; call is complex due to the need
        to simulate variable arguments in languages like Java, but the result will be something
        like: <pre><tt>ASTFactory.make(<i>root</i>, <i>c1</i>, ..., <i>cn</i>);</tt></pre>
        <p>In addition to the translation of the <tt>#(...)</tt> as a whole, the root and each
        child <tt><i>c1</i>..<i>cn</i></tt> will be translated. Within the context of a <tt>#(...)</tt>
        construct, you may use:<ul>
          <li><i><tt>id</tt></i> or <i><tt>label</tt></i> as a shorthand for <tt>#<i>id</i></tt> or <i><tt>#label</tt></i>.</li>
          <li><tt>[...]</tt> as a shorthand for <tt>#[...]</tt>.</li>
          <li><tt>(...)</tt> as a shorthand for <tt>#(...)</tt>. </li>
        </ul>
      </dd>
    </dl>
    <p>The target code generator performs this translation with the help of a special lexer
    that parses the actions and asks the code-generator to create appropriate substitutions
    for each translated item. </p>
    <h2><a name="_bb10"></a><a name="Invoking parsers that build trees">Invoking parsers that
    build trees</a></h2>
    <p>Assuming that you have defined a lexer <tt>L</tt> and a parser <tt>P</tt> in your
    grammar, you can invoke them sequentially on the system input stream as follows. </p>
    <pre><tt><i>L</i> lexer = new <i>L</i>(System.in);
<i>P</i> parser = new <i>P</i>(lexer);
parser.setASTNodeType(&quot;MyAST&quot;); // if special AST node
parser.<i>startRule</i>();</tt>   </pre>
    <p>If you have set <tt>buildAST=true</tt> in your parser grammar, then it will build an
    AST, which can be accessed via <tt>parser.getAST()</tt>. If you have defined a tree parser
    called <tt>T</tt>, you can invoke it with: </p>
    <pre><tt>T walker = new T();
walker.<i>startRule</i>(parser.getAST());    // walk tree</tt>  </pre>
    <p>If, in addition, you have set <tt>buildAST=true</tt> in your tree-parser to turn on
    transform mode, then you can access the resulting AST of the tree-walker: </p>
    <pre><tt>AST results = walker.getAST();
DumpASTVisitor visitor = new DumpASTVisitor();
visitor.visit(results);</tt></pre>
    <p>Where <tt>DumpASTVisitor</tt> is a predefined <tt>ASTVisitor</tt> implementation that
    simply prints the tree to the standard output.</p>
    <p>You can also use get a LISP-like print out of a tree via</p>
    <pre>String s = parser.getAST().toStringList();</pre>
    <h2><a name="_bb11"></a><a name="AST Factories">AST Factories</a></h2>
    <p>ANTLR uses a factory pattern to create and connect AST nodes. This is done to primarily
    to separate out the tree construction facility from the parser, but also gives you a hook
    in between the parser and the tree node construction.&nbsp; Subclass <tt>ASTFactory</tt>
    to alter the <tt>create</tt> methods.</p>
    <p>If you are only interested in specifying the AST node type at runtime, use the</p>
    <pre><tt>setASTNodeType(String className)</tt></pre>
    <p>method on the parser or factory.&nbsp; By default, trees are constructed of nodes of
    type <tt>CommonAST</tt>.</p>
    <p>The ASTFactory has some generically useful methods:</p>
    <pre>/** Copy a single node. clone() is not used because
 * we want to return an AST not a plain object...type
 * safety issue. Further, we want to have all AST node
 * creation go through the factory so creation can be
 * tracked. Returns null if t is null.
 */
public AST dup(AST t);</pre>
    <pre>/** Duplicate tree including siblings of root. */
public AST dupList(AST t);</pre>
    <pre>/**Duplicate a tree, assuming this is a root node
 * of a tree--duplicate that node and what's below;
 * ignore siblings of root node.
 */
public AST dupTree(AST t);</pre>
    <h2><a name="_bb12">AST enumerations</a></h2>
    <p>The AST <tt>findAll</tt> and <tt>findAllPartial</tt> methods return enumerations of
    tree nodes that you can walk.&nbsp; Interface</p>
    <pre>antlr.collections.ASTEnumeration</pre>
    <p>and</p>
    <pre>class antlr.Collections.impl.ASTEnumerator</pre>
    <p>implement this functionality.&nbsp; Here is an example:</p>
    <pre>// Print out all instances of <em>a-subtree-of-interest
// </em>found within tree 't'.
ASTEnumeration enum;
enum = t.findAll(<em>a-subtree-of-interest</em>);
while ( enum.hasMoreNodes() ) {
  System.out.println(
    enum.nextNode().toStringList()
  );
}</pre>
    <h2><a name="_bb13"></a><a name="A few examples">A few examples</a></h2>
    <pre><tt>
sum :term ( PLUS^ term)*
    ;</tt> </pre>
    <p>The &quot;<tt>^</tt>&quot; suffix on the <tt>PLUS</tt> tells ANTLR to create an
    additional node and place it as the root of whatever subtree has been constructed up until
    that point for rule <tt>sum</tt>. The subtrees returned by the <tt>term</tt> references
    are collected as children of the addition nodes.&nbsp; If the subrule is not matched, the
    associated nodes would not be added to the tree. The rule returns either the tree matched
    for the first <tt>term</tt> reference or a <tt>PLUS</tt>-rooted tree.</p>
    <p>The grammar annotations should be viewed as operators, not static specifications. In
    the above example, each iteration of the (...)* will create a new PLUS root, with the
    previous tree on the left, and the tree from the new <tt>term</tt> on the right, thus
    preserving the usual associatively for &quot;+&quot;.</p>
    <p>Look at the following rule that turns off default tree construction.</p>
    <pre><tt>decl!: 
    modifiers type ID SEMI;
	{ #decl = #([DECL], ID, ([TYPE] type),
                    ([MOD] modifiers) ); }
    ;</tt></pre>
    <p>In this example, a declaration is matched. The resulting AST has an
    &quot;imaginary&quot; <tt>DECL</tt> node at the root, with three children. The first child
    is the <tt>ID</tt> of the declaration. The second child is a subtree with an imaginary <tt>TYPE</tt>
    node at the root and the AST from the <tt>type</tt> rule as its child. The third child is
    a subtree with an imaginary <tt>MOD</tt> at the root and the results of the <tt>modifiers</tt>
    rule as its child.</p>
    <h2><a name="_bb14"></a><a name="Labeled subrules">Labeled subrules</a></h2>
    <p>[<big><i>THIS WILL NOT BE IMPLEMENTED AS LABELED SUBRULES...We'll do something else
    eventually.</i></big>] </p>
    <p>In 2.00 ANTLR, each rule has exactly one tree associated with it. Subrules simply add
    elements to the tree for the enclosing rule, which is normally what you want. For example,
    expression trees are easily built via: </p>
    <pre><tt>
expr: ID ( PLUS^ ID )*
    ;
</tt>    </pre>
    <p>However, many times you want the elements of a subrule to produce a tree that is
    independent of the rule's tree. Recall that exponents must be computed before coefficients
    are multiplied in for exponent terms. The following grammar matches the correct syntax. </p>
    <pre><tt>
// match exponent terms such as &quot;3*x^4&quot;
eterm
    :   expr MULT ID EXPONENT expr
    ;
</tt>    </pre>
    <p>However, to produce the correct AST, you would normally split the <tt>ID EXPONENT expr</tt>
    portion into another rule like this: </p>
    <pre><tt>
eterm:
    expr MULT^ exp
    ;

exp:
	ID EXPONENT^ expr
    ;
</tt>    </pre>
    <p>In this manner, each operator would be the root of the appropriate subrule. For input <tt>3*x^4</tt>,
    the tree would look like: </p>
    <pre><tt>
#(MULT 3 #(EXPONENT ID 4))
</tt>    </pre>
    <p>However, if you attempted to keep this grammar in the same rule: </p>
    <pre><tt>
eterm
    :   expr MULT^ (ID EXPONENT^ expr)
    ;
</tt>    </pre>
    <p>both &quot;<tt>^</tt>&quot; root operators would modify the same tree yielding </p>
    <pre><tt>
#(EXPONENT #(MULT 3 ID) 4)
</tt>    </pre>
    <p>This tree has the operators as roots, but they are associated with the wrong operands. </p>
    <p>Using a labeled subrule allows the original rule to generate the correct tree. </p>
    <pre><tt>
eterm
    :   expr MULT^ e:(ID EXPONENT^ expr)
    ;
</tt>    </pre>
    <p>In this case, for the same input <tt>3*x^4</tt>, the labeled subrule would build up its
    own subtree and make it the operand of the <tt>MULT</tt> tree of the <tt>eterm</tt> rule.
    The presence of the label alters the AST code generation for the elements within the
    subrule, making it operate more like a normal rule. Annotations of &quot;<tt>^</tt>&quot;
    make the node created for that token reference the root of the tree for the <tt>e</tt>
    subrule. </p>
    <p>Labeled subrules have a result AST that can be accessed just like the result AST for a
    rule. For example, we could rewrite the above decl example using labeled subrules (note
    the use of <tt>!</tt> at the start of the subrules to suppress automatic construction for
    the subrule): </p>
    <pre><tt>
decl!: 
    m:(! modifiers { #m = #([MOD] modifiers); } )
    t:(! type { #t = #([TYPE] type); } )
    ID
    SEMI;
    { #decl = #( [DECL] ID t m ); }
    ;
</tt>    </pre>
    <p>What about subrules that are closure loops? The same rules apply to a closure
    subrule--there is a single tree for that loop that is built up according to the AST
    operators annotating the elements of that loop. For example, consider the following rule. </p>
    <pre><tt>
term:   T^ i:(OP^ expr)+
    ;
</tt>    </pre>
    <p>For input <tt>T OP A OP B OP C</tt>, the following tree structure would be created: </p>
    <pre><tt>
#(T #(OP #(OP #(OP A) B) C) )
</tt>    </pre>
    <p>which can be drawn graphically as </p>
    <pre><tt>
T
|
OP
|
OP--C
|
OP--B
|
A
</tt>    </pre>
    <p>The first important thing to note is that each iteration of the loop in the subrule
    operates on the same tree. The resulting tree, after all iterations of the loop, is
    associated with the subrule label. The result tree for the above labeled subrule is: </p>
    <pre><tt>
#(OP #(OP #(OP A) B) C)
</tt>    </pre>
    <p>The second thing to note is that, because <tt>T</tt> is matched first and there is a
    root operator after it in the rule, <tt>T</tt> would be at the bottom of the tree if it
    were not for the label on the subrule. </p>
    <p>Loops will generally be used to build up lists of subtree. For example, if you want a
    list of polynomial assignments to produce a sibling list of <tt>ASSIGN</tt> subtrees, then
    the following rule you would normally split into two rules. </p>
    <pre><tt>
interp
    :   ( ID ASSIGN poly &quot;;&quot; )+
    ;
</tt>    </pre>
    <p>Normally, the following would be required </p>
    <pre><tt>
interp
    :   ( assign )+
    ;
assign
    :   ID ASSIGN^ poly &quot;;&quot;!
    ;
</tt>    </pre>
    <p>Labeling a subrule allows you to write the above example more easily as: </p>
    <pre><tt>
interp
    :   ( r:(ID ASSIGN^ poly &quot;;&quot;) )+
    ;
</tt>    </pre>
    <p>Each recognition of a subrule results in a tree and if the subrule is nested in a loop,
    all trees are returned as a list of trees (i.e., the roots of the subtrees are siblings).
    If the labeled subrule is suffixed with a &quot;<tt>!</tt>&quot;, then the tree(s) created
    by the subrule are not linked into the tree for the enclosing rule or subrule. </p>
    <p>Labeled subrules within labeled subrules result in trees that are linked into the
    surrounding subrule's tree. For example, the following rule results in a tree of the form <tt>X
    #( A #(B C) D) Y</tt>. </p>
    <pre><tt>
a   :   X r:( A^ s:(B^ C) D) Y
    ;
</tt>    </pre>
    <p>Labeled subrules within nonlabeled subrules result in trees that are linked into the
    surrounding rule's tree. For example, the following rule results in a tree of the form <tt>#(A
    X #(B C) D Y)</tt>. </p>
    <pre><tt>
a   :   X ( A^ s:(B^ C) D) Y
    ;</tt>    </pre>
    <h2><a name="_bb15"></a><a name="Reference nodes">Reference nodes</a></h2>
    <p><b>Not implemented.</b> A node that does nothing but refer to another node in the tree.
    Nice for embedding the same tree in multiple lists. </p>
    <h2><a name="_bb16"></a><a name="Required AST functionality and form">Required AST
    functionality and form</a></h2>
    <p>The data structure representing your trees can have any form or type name as long as
    they implement the <tt>AST</tt> interface: </p>
    <pre><tt>package antlr.collections;

/** Minimal AST node interface used by ANTLR
 *  AST generation and tree-walker.
 */
public interface AST {
    /** Get the token type for this node */
    public int getType();

    /** Set the token type for this node */
    public void setType(int ttype);

    /** Get the token text for this node */
    public String getText();

    /** Set the token text for this node */
    public void setText(String text);

    /** Get the first child of this node;
     *  null if no children */
    public AST getFirstChild();

    /** Set the first child of a node */
    public void setFirstChild(AST c);

    /** Get the next sibling in line after this one */
    public AST getNextSibling();

    /** Set the next sibling after this one */
    public void setNextSibling(AST n);

    /** Add a (rightmost) child to this node */
    public void addChild(AST node);</tt></pre>
    <pre><strong><tt>// NEW FOR 2.20:</tt></strong></pre>
    <pre>    /** Are two nodes exactly equal? */
    public boolean equals(AST t);</pre>
    <pre>    /** Are two lists of nodes/subtrees exactly equal
     *  in structure and content? */
    public boolean equalsList(AST t);</pre>
    <pre>    /** Are two lists of nodes/subtrees partially equal?
     *  In other words, 'this' can be bigger than 't' */
    public boolean equalsListPartial(AST t);</pre>
    <pre>    /** Are two nodes/subtrees exactly equal? */
    public boolean equalsTree(AST t);</pre>
    <pre>    /** Are two nodes/subtrees exactly partially equal?
     *  In other words, 'this' can be bigger than 't'.*/
    public boolean equalsTreePartial(AST t);</pre>
    <pre>    /** Return an enumeration of all exact tree matches
     *  for tree within 'this'. */
    public ASTEnumeration findAll(AST tree);</pre>
    <pre>    /** Return an enumeration of all partial tree
     *  matches for tree within 'this'. */
    public ASTEnumeration findAllPartial(AST subtree);</pre>
    <pre>    /** Init a node with token type and text */
    public void initialize(int t, String txt);</pre>
    <pre>    /** Init a node using content from 't' */
    public void initialize(AST t);</pre>
    <pre>    /** Init a node using content from 't' */
    public void initialize(Token t);</pre>
    <pre>    /** Convert node to printable form */
    public String toString();</pre>
    <pre>    /** Treat 'this' as list (i.e., consider 'this'
     *  siblings) and convert to printable form */
    public String toStringList();</pre>
    <pre>    /** Treat 'this' as tree root (i.e., don't consider
     *  'this' siblings) and convert to printable
     *  form */
    public String toStringTree();<tt>
}</tt></pre>
    <p>This scheme does not preclude the use of heterogeneous trees versus homogeneous trees.
    However, you will need to write extra code to create heterogeneous trees (via a subclass
    of <tt>ASTFactory</tt>), whereas the homogeneous trees are free. </td>
  </tr>
</table>
</body>
</html>
