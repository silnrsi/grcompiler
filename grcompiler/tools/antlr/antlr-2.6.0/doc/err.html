<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>Error Handling and Recovery</title>
</head>

<body bgcolor="#FFFFFF">

<table border="0">
  <tr>
    <td align="center" valign="top" width="120" bgcolor="#FBFCDC"><font color="#FFFFFF"
    size="4"><img src="logo.gif" width="111" height="144"><br>
    </font><strong><a href="http://www.magelang.com"><font size="3">M</font><font size="2">AGELANG</font></a><font
    size="3">!</font></strong><p><a href="http://www.ANTLR.org"><font size="4">Home</font></a></td>
    <td></td>
    <td valign="top" width="520"><h2><a name="_bb1"></a><a name="lexicalanalysis">Error
    Handling and Recovery</a></h2>
    <p>All syntactic and semantic errors cause parser exceptions to be thrown. In particular,
    the methods used to match tokens in the parser base class (match et al) throw
    MismatchedTokenException. If the lookahead predicts no alternative of a production in
    either the parser or lexer, then a NoViableAltException is thrown. The methods in the
    lexer base class used to match characters (match et al) throw ScannerException. </p>
    <p>When the parser (or lexer) is implemented in an object-priented language, the parser
    exceptions correspond to the exceptions of the language. Otherwise, parser exceptions must
    be simulated by the code generator in a more laborious fashion. </p>
    <p>ANTLR will generate default error-handling code, or you may specify your own exception
    handlers. Either case results (where supported by the language) in the creation of a <tt>try/catch</tt>
    block. Such <tt>try{}</tt> blocks surround the generated code for the grammar element of
    interest (rule, alternate, token reference, or rule reference). If no exception handlers
    (default or otherwise) are specified, then the exception will propagate all the way out of
    the parser to the calling program. </p>
    <p>ANTLR's default exception handling is good to get something working, but you will have
    more control over error-reporting and resynchronization if you write your own exception
    handlers. </p>
    <p>Note that the '@' exception specification of PCCTS 1.33 does not apply to ANTLR 2.0.</p>
    <h3><a name="_bb2"></a><a name="Modifying Default Error Messages With Paraphrases">Modifying
    Default Error Messages With Paraphrases</a></h3>
    <p>The name or definition of a token in your lexer is rarely meaningful to the user of
    your recognizer or translator.&nbsp; For example, instead of seeing</p>
    <pre>Error: line(1), expecting ID, found ';'</pre>
    <p>you can have the parser generate:</p>
    <pre>Error: line(1), expecting an identifier, found ';'</pre>
    <p>ANTLR provides an easy way to specify a string to use in place of the token name.&nbsp;
    In the definition for ID, use the paraphrase option:</p>
    <pre>ID
options {
  paraphrase = &quot;an identifier&quot;;
}
  : ('a'..'z'|'A'..'Z'|'_')
    ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
  ;</pre>
    <p>Note that this paraphrase goes into the token types text file (ANTLR's persistence
    file).&nbsp; In other words, a grammar that uses this vocabulary will also use the
    paraphrase. </p>
    <h3><a name="_bb3">Parser Exception Handling</a></a></h3>
    <p>ANTLR 2.0 generates recursive-descent recognizers. Since recursive-descent recognizers
    operate by recursively calling the rule-matching methods, this results in a call stack
    that is populated by the contexts of the recursive-descent methods. Parser exception
    handling for grammar rules is a lot like exception handling in a language like C++ or
    Java. Namely, when an exception is thrown, the normal thread of execution is stopped, and
    functions on the call stack are exited sequentially until one is encountered that wants to
    catch the exception. When an exception is caught, execution resumes at that point. </p>
    <p>In ANTLR 2.0, parser exceptions are thrown when (a) there is a syntax error, (b) there
    is a failed validating semantic predicate, or (c) you throw a parser exception from an
    action. </p>
    <p>In all cases, the recursive-descent functions on the call stack are exited until an
    exception handler is encountered for that exception type or one of its base classes (in
    non-object-oriented languages, the hierarchy of execption types is not implemented by a
    class hierarchy). Exception handlers arise in one of two ways. First, if you do nothing,
    ANTLR will generate a default exception handler for every parser rule. The default
    exception handler will report an error, sync to the follow set of the rule, and return
    from that rule. Second, you may specify your own exception handlers in a variety of ways,
    as described later. </p>
    <p>If you specify an exception handler for a rule, then the default exception handler is
    not generated for that rule. In addition, you may control the generation of default
    exception handlers with a <a href="options.html#defaultErrorHandler">per-grammar or
    per-rule option</a>. </p>
    <h3><a name="_bb4">Specifying Parser Exception-Handlers</a></a></h3>
    <p>You may attach exception handlers to a rule, an alternative, or a labeled element. The
    general form for specifying an exception handler is: <tt></p>
    <pre>
exception [label]
catch [exceptionType exceptionVariable] { action }
catch ...
catch ...
</tt>  </pre>
    <p>where the label is only used for attaching exceptions to labeled elements. The <tt>exceptionType</tt>
    is the exception (or class of exceptions) to catch, and the <tt>exceptionVariable</tt> is
    the variable name of the caught exception, so that the action can process the exception if
    desired. Here is an example that catches an exception for the rule, for an alternate and
    for a labeled element: <tt></p>
    <pre>
rule:   a:A B C
    |   D E
        exception // for alternate
          catch [ParserException ex] {
            reportError(ex.toString());
        }
    ;
    exception // for rule
    catch [ParserException ex] {
       reportError(ex.toString());
    }
    exception[a] // for a:A
    catch [ParserException ex] {
       reportError(ex.toString());
    }
</tt>  </pre>
    <p>Note that exceptions attached to alternates and labeled elements <b>do not</b> cause
    the rule to exit. Matching and control flow continues as if the error had not occurred.
    Because of this, you must be careful not to use any variables that would have been set by
    a successful match when an exception is caught. </td>
  </tr>
</table>
</body>
</html>
